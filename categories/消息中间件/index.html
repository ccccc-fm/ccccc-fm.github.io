<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 消息中间件 - rxws</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="rxws"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="rxws"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="rxws"><meta property="og:url" content="http://rxws.com/"><meta property="og:site_name" content="rxws"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://rxws.com/img/og_image.png"><meta property="article:author" content="chenfm"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://rxws.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://rxws.com"},"headline":"rxws","image":["http://rxws.com/img/og_image.png"],"author":{"@type":"Person","name":"chenfm"},"publisher":{"@type":"Organization","name":"rxws","logo":{"@type":"ImageObject","url":"http://rxws.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ea19c8faf6b456991b902d045bc5e1be";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="rxws" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">消息中间件</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-11-13T15:11:02.000Z" title="11/13/2022, 11:11:02 PM">2022-11-13</time>发表</span><span class="level-item"><time dateTime="2022-11-24T01:20:31.379Z" title="11/24/2022, 9:20:31 AM">2022-11-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a></span><span class="level-item">1 小时读完 (大约8066个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/13/RocketMq%E5%85%A5%E9%97%A8/">RocketMq入门</a></h1><div class="content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>MQ的用处</li>
</ol>
<ul>
<li>限流削峰</li>
<li>异步解耦</li>
<li>数据收集：收集业务日志、监控数据、用户行为</li>
</ul>
<h2 id="RocketMQ基础"><a href="#RocketMQ基础" class="headerlink" title="RocketMQ基础"></a>RocketMQ基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>消息(message)</strong>: 生产和消费数据的最小单位，每条消息必须属于一个主题</li>
<li><strong>主题(topic)</strong>: 一类消息的集合，每个主题包含多个消息。一个生产者可以生产多个topic消息，一个消费者只能消费一个topic</li>
<li>**标签(Tag)**：为消息设置的标签用于同一个topic下区分不同类型的消息</li>
<li>**队列(Queue)**：存储消息的物理实体，一个topic包含多个Queue，每个Queue中存放的就是该Topic的消息。一个topic中的queue也叫topic中消息的分区。一个queue只能被一个消费者消费</li>
<li><strong>消息标识(MessageId&#x2F;key)</strong>: 消息的唯一标识，生产者发送消息会产生一个msgId，消费者接收消息会产生offsetMsgId，用户指定而定业务id叫key</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ol>
<li>producer：生产消息</li>
<li>consumer：进行消息消费</li>
</ol>
<ul>
<li>负载均衡：一个topic中的queue会平均分配给消费者组中的消费者</li>
<li>容错：组中的一个消费者挂掉后，其他的消费者会平分该消费者的queue</li>
<li>消费者组只能消费一个topic的消息，不能同时消费多个topic的消息</li>
<li>一个消费者组中的消费者必须订阅完全相同的topic</li>
</ul>
<ol>
<li>NameServer：broker和topic路由的注册中心，功能：broker管理、路由信息管理</li>
<li>broker：用于存储和转发消息</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>①:启动namerserver -&gt; ②:启动broker -&gt; ③:创建topic -&gt; ④:生产消息 -&gt; ⑤:消费消息<br>1：<strong>namerserver</strong><br>因为rockermq的注册中心是无状态的，所以它的broker信息与路由信息需要broker主动发送给nameserver，所以先启动nameserver，关闭时先关闭broker<br>2：<strong>创建topic</strong><br>发送消息前应该先创建topic也可以设置自动创建，手动创建topic有两种方式：集群模式和broker模式，区别在于集群模式创建的topic在每个broker中的读写队列数量都是一致的，而broker模式你需要在逐个选择broker进行创建topic，读写队列自然数量自然可以不同。<br>手动创建topic的参数有四个：创建模式、读队列数量、写队列数量、perm。perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。<br>3：<strong>读写队列</strong><br>生产者将消息写入写队列，消费者从队列中读取消息。在物理上读写队列是同一个队列，一般情况读写队列数量是相同的。但broker模式创建topic时读写队列数量不同，这样是为了缩容。<br><code>缩容</code>：如现在读写队列数量都为16个，需要缩容为都是8个，且保证消息不丢失。可以先将写队列动态调整为8个，此时只有8个写队列在往里写消息，16个队列在消费消息，待停止写入消息的那8个队列的消息消费完了之后，将读队列的数量修改为8，即实现了缩容</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><ol>
<li><strong>生产过程</strong>：<ul>
<li>Producer发送消息之前，会先向NameServer发出获取 消息Topic的路由信息 的请求</li>
<li>NameServer返回该Topic的 路由表 及 Broker列表<blockquote>
<p>路由表是个map，key是topic名称，value是broker列表，列表中没有地址只有名称，produer通过路由表找到brokername,再从broker列表中找到broker地址</p>
</blockquote>
</li>
<li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息<blockquote>
<p>Queue选择算法：无序消息：轮询和最小投递延迟算法</p>
</blockquote>
</li>
<li>Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</li>
<li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</li>
</ul>
</li>
</ol>
<blockquote>
<p>轮询算法：<br>默认选择的算法，保证消息在队列中均匀的消费<br>消息1发送个队列1，消息2发送给队列2，以此类推。缺点：消息1发送后，生产者要等消息成功发送后再把消息2发送给队列2，不成功下次还是给队列1发送。这样一来可能造成<strong>消息在生产者的缓存队列中大量积压</strong>，影响性能。</p>
</blockquote>
<blockquote>
<p>最小投递延迟算法<br>统计每个队列投递消息的延迟，选择最小的队列进行投递，缺点：可能造成一个队列中存放了大量消息，造成消费者消费者能力下降，<strong>消息在MQ中积压严重</strong></p>
</blockquote>
<ol>
<li>消息的存储<br>RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。</li>
<li>indexFile<br>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询<br>是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索<br>引数据是在 包含了key的消息 被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</li>
</ol>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><ol>
<li><strong>获取消息</strong></li>
</ol>
<ul>
<li>**拉取式消费(pull)**：Consumer主动从Broker中拉取消息。实时性弱</li>
</ul>
<blockquote>
<p>拉取消息的时间是用户指定的，拉取时间需要注意平衡,RocketMq默认使用拉取式消费，拉取间隔15秒</p>
</blockquote>
<ul>
<li><strong>推送式消费(push)</strong>: broker收到消息后主动推送给consumer，实时性高，耗费资源</li>
</ul>
<blockquote>
<p>consumer向其关联的queue注册了监听器，这需要长连接，所以耗费资源(与每个broker建立长连接)</p>
</blockquote>
<ul>
<li>**长轮询(long polling)**：消费者定时去broker中获取消息，如果没获取到消息，保持连接一段时间，比如30s，30s内没有消息，则断开连接，30s内有消息，则消费消息且再等30s。中和了pull和push的利弊。</li>
</ul>
<ol>
<li><strong>消费消息</strong></li>
</ol>
<ul>
<li><strong>广播消费</strong><br>消费者组中的每个消费者都接收topic全量的消息，各自进行消费，一条消息被消费n次，消费进度保存在消费者中</li>
<li><strong>集群消费</strong><br>消费者组中的消费者平摊topic所有的消息，一条消息被消费一次，进度需要共享，所以消费进度存放在broker中</li>
</ul>
<ol>
<li><p><strong>Rebalance机制</strong><br>Relablance机制指当消费者组中的消费者数量发生变化（宕机、新增）时、消费者所订阅的Topic中的Queue数量发生变化时，将Topic中的多个Queue重新分配给消费者的机制。Reblance机制的前提是集群消费。<br>在进行Reblance时，会导致消费暂停，重新分配Queue后继续消费，这可能会导致消息重复或者暂停时间过长导致消息积压。优点是可以提升消费能力</p>
</li>
<li><p><strong>Queue分配算法</strong></p>
</li>
</ol>
<ul>
<li><strong>平均分配</strong>：先根据Queue的数量和消费者的数量计算每个消费者分配的Queue数量，如不能平均分配，则将多于的Queue逐个分配个消费者。</li>
<li><strong>环形平均分配</strong>：消费者逐个从Queue队列中领取，与平均分配不同的是，平均分配的Queue是连续的，比如Consumer1会拿到0、1、3的Queue，而环形会拿到0、3、6的Queue</li>
<li><strong>一致hash策略</strong>：将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过 顺时针 方向，距离queue最近的那个consumer就是该queue要分配的consumer。（分配不均）</li>
<li><strong>同机房分配</strong>：根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配</li>
</ul>
<h3 id="订阅关系一致性"><a href="#订阅关系一致性" class="headerlink" title="订阅关系一致性"></a><strong>订阅关系一致性</strong></h3><p>错误的订阅关系会导致消费逻辑混乱、丢失消息<br>正确的订阅关系：多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。<br>错误的订阅关系：</p>
<ul>
<li>一个消费者组中的消费者订阅了不同的Topic</li>
<li>一个消费者组中的消费者订阅了相同的Topic，不同的Tag</li>
<li>一个消费者组中的消费者订阅了不同数量的消费者</li>
</ul>
<h3 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h3><p>某个操作执行多次和执行一次对系统的影响都是一样的，则为幂等操作。读操作一般都是幂等的，幂等性一般讨论的都是写操作。<br>对于RocketMq来说，如果出现消息重复，就可能会重复消费影响业务。</p>
<h4 id="RocketMq可能出现的消息重复场景"><a href="#RocketMq可能出现的消息重复场景" class="headerlink" title="RocketMq可能出现的消息重复场景"></a>RocketMq可能出现的消息重复场景</h4><ul>
<li>producer将消息发送给broker，broker持久化消息后因为网络原因没有给produce发送接收到消息的响应，produce会判断为消息发送失败，会重复发送失败的消息，并不会重新生成msgId。</li>
<li>consumer接收到消息后没有给broker成功的响应，broker会重复给consumer发送消息</li>
<li>Rebalance时导致消息重复</li>
</ul>
<h3 id="通用的幂等性解决方案"><a href="#通用的幂等性解决方案" class="headerlink" title="通用的幂等性解决方案"></a>通用的幂等性解决方案</h3><p>通常通过幂等令牌实现幂等性操作，如支付操作：<br>producer发送消息时带上幂等令牌，支付中可能是订单号。consumer处理消息时进行三步处理：</p>
<ol>
<li>检查缓存中有无与令牌相同的key，如存在则认定为重复操作，如不存在则进行下一步</li>
<li>检查数据库中有无该令牌为索引的数据，如存在则认定为重复操作，不存在则进行下一步</li>
<li>进行到这一步就已经认定为未重复，进行业务操作，然后将令牌存入缓存、数据库</li>
</ol>
<blockquote>
<p>为什么缓存中判重后还要在数据库中再次判重？因为为了性能，缓存中一般存的都是有有效期的，存在key过期而不存在的情况</p>
</blockquote>
<p>在RocketMq中producer可以在发送消息时将幂等令牌设置为消息的key</p>
<pre><code>message.setKey(&quot;XXXXX&quot;)
</code></pre>
<blockquote>
<p>message的标识有三个：msgId(producer生成)、offsetMsgId(broker生成)、key(用户指定的业务唯一标识)</p>
</blockquote>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><ul>
<li>依赖，以下案例使用rocketmq-client依赖举例</li>
</ul>
<!---->

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><p>消息根据发送类型分为：</p>
<ul>
<li>同步发送：producer发送一条消息后，收到MQ的响应后发送下一条消息，可靠性高效率低</li>
<li>异步发送：无需等待响应(但会接收响应)，直接发送下一条，可靠性一般、效率一般</li>
<li>单向发送：不接收响应，可靠性差，效率高</li>
</ul>
<p>producer发送消息</p>
<pre><code>//失败重试次数、默认2次
producer.setRetryTimesWhenSendFailed(3);

//发送超时时间，默认3秒，单向消息设置超时时间貌似会报超时错误
//超时错误：sendDefaultImpl call timeout
producer.setSendMsgTimeout(5000);

//指定新创建的Topic的Queue数量为2，默认为4
producer.setDefaultTopicQueueNums(2);
</code></pre>
<!---->

<pre><code>    /**
     * 发送同步消息
     * @throws Exception
     */
    @Test
    public void syncSend() throws Exception &#123;
        DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;);
        producer.setNamesrvAddr(IP_PORT);
        producer.start();
        byte[] body = &quot;123&quot;.getBytes();
        Message msg = new Message(&quot;testSyncTopic&quot;, &quot;test&quot;, body);
        SendResult send = producer.send(msg);
        producer.shutdown();
    &#125;

    /**
     * 发送异步消息
     * @throws Exception
     */
    @Test
    public void asyncSend() throws Exception &#123;
        DefaultMQProducer producer = new DefaultMQProducer(&quot;myAsyncGroup&quot;);
        producer.setNamesrvAddr(IP_PORT);
        producer.start();
        byte[] body = &quot;test&quot;.getBytes();
        Message msg = new Message(&quot;testSyncTopic&quot;, &quot;test&quot;, body);
        producer.send(msg, new SendCallback() &#123;
            @Override
            public void onSuccess(SendResult sendResult) &#123;
                //发送成功的回调，sendResult为返回结果
                System.out.println(sendResult);
            &#125;

            @Override
            public void onException(Throwable throwable) &#123;
                //发送失败的异常信息
                System.out.println(throwable.getMessage());
            &#125;
        &#125;);
        //异步发送，如果直接关闭生产者，可能消息还没发完
        Thread.sleep(3000);
        producer.shutdown();
    &#125;

    /**
     * 发送单单向消息
     * @throws Exception
     */
    @Test
    public void oneWaySend() throws Exception &#123;
        DefaultMQProducer producer = new DefaultMQProducer(&quot;myAsyncGroup&quot;);
        producer.setNamesrvAddr(IP_PORT);
        producer.start();
        byte[] body = &quot;test&quot;.getBytes();
        Message msg = new Message(&quot;testOneWayTopic&quot;, &quot;test&quot;, body);
        producer.sendOneway(msg);
        producer.shutdown();
    &#125;
</code></pre>
<p>consumer接收消息</p>
<pre><code>// 指定采用“广播模式”进行消费，默认为“集群模式”
consumer.setMessageModel(MessageModel.BROADCASTING);
</code></pre>
<!---->

<pre><code>    /**
     * 接收消息
     * @throws Exception
     */
    @Test
    public void consumer() throws Exception &#123;
        while (true)&#123;
            System.out.println(&quot;into&quot;);
            DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;);
            consumer.setNamesrvAddr(IP_PORT);
            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
            consumer.subscribe(&quot;testSyncTopic&quot;,&quot;*&quot;);
//            consumer.subscribe(&quot;testOneWayTopic&quot;,&quot;*&quot;);
            consumer.registerMessageListener(new MessageListenerConcurrently() &#123;
                @Override
                public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) &#123;
                    list.forEach(msg-&gt;&#123;
                        System.out.println(new String(msg.getBody()));
                    &#125;);
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                &#125;
            &#125;);
            consumer.start();
            Thread.sleep(5000);
        &#125;
    &#125;
</code></pre>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息指的是，严格按照消息的 发送顺序 进行 消费 的消息(FIFO)。</p>
<ul>
<li><p><strong>普通消息为什么不是顺序的？</strong><br>producer生产消息后会根据算法(轮询、最小投递)将消息投递到不同的Queue中，每个Queue中虽然是先进先出的，但是不同Queue中的消费速度可不一样，将消息投递到不同的Queue中当然不是顺序的。<br>所以要保证消息的顺序，就要保证消息在同一个Queue中，比如一个订单的三条消息：创建、付款、完成。三条都在一个Queue中。<br><code>注意:</code>一个Queue只能被一个消费者消费，所以放在一个Queue中就是顺序的</p>
</li>
<li><p><strong>如何保证消息在一个Queue中？</strong></p>
</li>
</ul>
<ol>
<li>producer设置Topic下的Queue数量为1.称之为全局顺序</li>
<li>producer通过Queue选择算法指定消息投递到哪个Queue中，订单场景中就是设置每个订单的三个消息都能进到同一个Queue中，称之为部分顺序</li>
</ol>
<p>全局顺序与部分顺序的代码是相同的。<br>Queue选择算法就是通过计算得出消息投递的Queue索引，相同订单的三个消息计算出的索引是相同的，就会被投递到同一队列。常用的方法就是Hash取模，用订单ID%队列数量得到Queue索引</p>
<ul>
<li><strong>如何完成一次顺序消息的发送、消费？</strong></li>
</ul>
<ol>
<li>保证消息在同一个Queue中</li>
<li>同步发送，<strong>顺序消息只能用同步发送</strong>(虽然提供了异步方法，但不能保证有序)</li>
<li>consumer使用有序消费模式进行消费MessageListenerOrderly</li>
</ol>
<ul>
<li>代码<br><code>注意：</code>订单id是通过send方法的第三个参数传递进去的、消费者中用顺序监听器<br>最后观察消费者的输出，同一个订单的消息都在同一个Queue中</li>
</ul>
<!---->

<pre><code>    /**
     * 发送顺序消息
     * @throws Exception
     */
    @Test
    public void syncSend() throws Exception &#123;
        DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;);
        producer.setNamesrvAddr(IP_PORT);
        producer.start();
        Integer[] orderIds =new Integer[]&#123;111,222,333&#125;;
        for (Integer i = 0; i &lt; 13; i++) &#123;
            //有4条消息的orderId是111，这4条消息计算Queue索引时都是相同的，就会被投递到相同的队列中
            int index = i%3;
            Integer orderId = orderIds[index];
            byte[] body = orderId.toString().concat(&quot;-&quot;).concat(i.toString()).getBytes();
            Message msg = new Message(&quot;testOrderlyTopic&quot;, &quot;test&quot;, body);
            //传递三个参数：message,选择器,选择器Key  这个选择器key就是内部类方法select()的参数
            SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;
                @Override
                public MessageQueue select(List&lt;MessageQueue&gt; list, Message message, Object key) &#123;
                    Integer orderId = (Integer) key;
                    //计算投递的Queue的索引
                    int queueIndex = orderId % list.size();
                    return list.get(queueIndex);
                &#125;
            &#125;,orderId);

        &#125;
        producer.shutdown();
    &#125;

    /**
     * 接收消息
     * @throws Exception
     */
    @Test
    public void consumer() throws Exception &#123;
        while (true)&#123;
            System.out.println(&quot;into&quot;);
            DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;);
            consumer.setNamesrvAddr(IP_PORT);
            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
            consumer.subscribe(&quot;testOrderlyTopic&quot;,&quot;*&quot;);
            consumer.registerMessageListener(new MessageListenerOrderly() &#123;
                @Override
                public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext) &#123;
                    list.forEach(entity-&gt;&#123;
                        int queueId = entity.getQueueId();
                        String bodyString = new String(entity.getBody());
                        System.out.println(queueId+&quot;----&quot;+bodyString);
                    &#125;);
                    return ConsumeOrderlyStatus.SUCCESS;
                &#125;
            &#125;);
            consumer.start();
            Thread.sleep(500);
        &#125;
    &#125;
</code></pre>
<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p>延时消息顾名思义就是延迟发送消息，典型的应用场景就是一段时间内未支付，则结束订单。<br>开启订单后，发送一条延时30分钟的消息，30分钟后消费者收到消息，拿到订单号，检查该订单是否已经支付，如果未支付则结束订单，将商品放回商品库。</p>
<p>Rocketmq中不能设置延时时间，只能设置延时等级，不同的延时等级对应不同的延时时间，延时等级从1开始。<br>延时等级定义在RocketMQ服务端的 MessageStoreConfig 类中。如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>
<pre><code>messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d
</code></pre>
<ol>
<li><p>实现原理<br>producer将消息发送到broker后，broker会将消息先放到commitlog中，然后再分发到对应的queue，在分发之前会判断消息有无延时，如没有延时，则正常发送，如果有延时等级将会修改消息的topic为SCHEDULE_TOPIC_XXXX，并将消息发送到该topic的queue下。<br>broker中有个延迟消息服务类ScheuleMessageService，会消费该主题下的消息，该服务类在到达延时时间后将消息的延时等级设为0，重新投递到原topic中。</p>
</li>
<li><p>代码举例<br>比较简单</p>
</li>
</ol>
<!---->

<pre><code>msg.setDelayTimeLevel(3);
</code></pre>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><h4 id="分布式事务概念"><a href="#分布式事务概念" class="headerlink" title="分布式事务概念"></a>分布式事务概念</h4><ol>
<li><strong>什么是一致性？</strong><br>在分布式系统中，一致性（Consistency）是指多副本（Replications）问题中的数据一致性<br>一致性的种类：事务一致性、数据一致性<br>数据一致性的种类：</li>
</ol>
<ul>
<li>弱一致性：如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性</li>
<li>强一致性：同步复制数据，所有节点中的数据是一样的</li>
<li>最终一致性：就是在一段时间后，节点间的数据会最终达到一致状态，是弱一致性的一种</li>
<li>顺序一致性：任何一次读都能读到某个数据的最近一次写的数据</li>
</ul>
<ol>
<li><strong>什么是XA协议？</strong><br>一套分布式事务标准，使用了两阶段提交来保证分布式事务的完整性<br>XA模式中有三个重要组件：TC、TM、RM。</li>
</ol>
<ul>
<li><strong>TC</strong>: Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。RocketMQ中Broker充当着TC。</li>
<li><strong>TM</strong>：Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它<br>实际是全局事务的发起者。RocketMQ中事务消息的Producer充当着TM。</li>
<li><strong>RM</strong>：Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事<br>务的状态，并驱动分支事务提交或回滚。RocketMQ中事务消息的Producer及Broker均是RM。</li>
</ul>
<ol>
<li><p><strong>XA模型</strong></p>
<ol>
<li>TM向TC发起指令，开启一个全局事务。</li>
<li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li>
<li>各个RM在接收到指令后会在进行本地事务预执行。</li>
<li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败</li>
<li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令<ul>
<li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li>
<li>只要有结果是失败响应，则向TC发送Global Rollback指令</li>
</ul>
</li>
<li>TC在接收到指令后再次向RM发送确认指令</li>
</ol>
</li>
<li><p><strong>RocketMq中的概念</strong></p>
</li>
</ol>
<img src="/img/posts/rocketmqTrascation.png" class="[rocketMq流程]" title="[1996] [544] " alt="事务消息流程图">


<ul>
<li>半事务消息：咱不能投送的消息，producer已经将消息发送到了broker但是事务状态没有确定，此时该消息对于consumer不可见</li>
<li>本地事务状态：producer回调操作执行的结果，TC会将本地事务状态发送给TM，TM根据本地事务状态确定全局事务状态</li>
<li>消息回查：即重新查询本地事务的执行状态，本地事务返回的结果如果是不确定，则会进行回查，重新返回本地事务状态</li>
</ul>
<h4 id="RocketMq中的事务消息"><a href="#RocketMq中的事务消息" class="headerlink" title="RocketMq中的事务消息"></a>RocketMq中的事务消息</h4><p>A银行给B银行转账，分为4个步骤<br>① A向B发送存款增加一万元的消息<br>② A扣款一万元<br>③ B收到消息，消费消息<br>④ B增加存款一万元</p>
<blockquote>
<p>Rocketmq只能做到步骤一和步骤二具有原子性，要想四个步骤成为一个操作，需要人工干预，见本节末。</p>
</blockquote>
<p>如何保证步骤一和步骤二是一个原子操作，RocketMq的操作流程如下：</p>
<ul>
<li>Producer向Broker端发送Half Message(半事务消息)；</li>
<li>broker给producer响应Half Message发送成功</li>
<li>producer收到消息发送成功的ACK，去执行本地事务（扣款操作）</li>
<li>本地事务执行完毕，返回本地事务状态：成功、失败、未知。broker根据本地事务状态执行commit或rollback<br>成功(commit)：消息真正发送给consumer<br>失败(rollback): 事务失败，消息不会发送给consumer，一段时间后清除消息<br>未知(unknow): 状态不确定，进行消息回查，重新确认消息状态<br>（正常的事务消息到这一步就已经结束）</li>
<li>如果本地事务执行超时时，broker会主动发起消息回查</li>
<li>producer进行消息回查，返回本地事务状态</li>
<li>broker根据本地事务状态执行commit或rollback</li>
</ul>
<blockquote>
<p>其中消息回查的结果如果还是unknow，则会继续回查，直到达到配置的最大回查次数，达到次数就报错<br>最大回查次数、回查间隔时间等都是可以配置的</p>
</blockquote>
<h4 id="代码举例-1"><a href="#代码举例-1" class="headerlink" title="代码举例"></a>代码举例</h4><ul>
<li>定义事务监听器，定义本地事务和消息回查</li>
</ul>
<!---->

<pre><code>/**
 * 事务监听器，本地事务和消息回查都在其中
 */
class MyMqTransactionListener implements TransactionListener &#123;

    /**
     * 本地事务
     * @param message 消息
     * @param args producer发送事务消息时传递的参数，用于执行本地事务时使用。不用就不传。此处的值应为123
     * @return 返回本地事务状态：LocalTransactionState  有三种状态
     */
    @Override
    public LocalTransactionState executeLocalTransaction(Message message, Object args) &#123;
        System.out.println(&quot;执行本地事务，A扣款操作~~~~&quot;);
        //返回执行成功，执行成功后broker会把消息发送给consumer
        //return LocalTransactionState.COMMIT_MESSAGE;
        //返回执行失败，失败后broker不会把消息发送给consumer
        //return LocalTransactionState.ROLLBACK_MESSAGE;
        //返回执行未知：去执行消息回查
        return LocalTransactionState.UNKNOW;
    &#125;

    /**
     * 消息回查
     * @param messageExt 消息
     * @return 返回本地事务状态，与执行本地事务的返回效果相同
     */
    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) &#123;
        System.out.println(&quot;执行消息回查&quot;);
        return LocalTransactionState.COMMIT_MESSAGE;
    &#125;
&#125;
</code></pre>
<ul>
<li>发送消息<br>注意：生产者的类型不再是DefaultMQProducer了、发送方法使用事务发送方法，可以使用业务参数<br>消费者正常使用就行</li>
</ul>
<!---->

<pre><code>    /**
     * 发送事务消息
     * @throws Exception
     */
    @Test
    public void sendTransactionMsg() throws Exception &#123;
        //定义事务生产者而不是默认的生产者
        TransactionMQProducer producer = new TransactionMQProducer(&quot;myGroup1&quot;);
        producer.setNamesrvAddr(IP_PORT);
        //1: 定义一个线程池给producer去处理本地事务、消息回查
        /**
         * @param corePoolSize 线程池核心线程数
         * @param maximumPoolSize 线程池中最多线程数
         * @param keepAliveTime 线程池中空闲线程的存活时间
         * @param unit 时间单位
         * @param workQueue 临时存放任务的队列，其参数就是队列的长度
         * @param threadFactory 线程工厂
         */
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                10,
                50,
                10L,
                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(20),
                (Runnable r) -&gt; new Thread(&quot;Order Transaction Massage Thread&quot;));
        producer.setExecutorService(executor);

        //2: 设置事务监听器，监听器中执行本地事务与消息回查，需要自己定义
        producer.setTransactionListener(new MyMqTransactionListener());

        //3：发送事务消息
        producer.start();
        Message msg = new Message(&quot;transactionTopic&quot;, &quot;test&quot;, &quot;hello&quot;.getBytes());
        TransactionSendResult result = producer.sendMessageInTransaction(msg, &quot;123&quot;);
        System.out.println(&quot;发送结果：&quot;+result);

        producer.shutdown();
    &#125;
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>RocketMq不能发送延时消息、批量消息</li>
<li>以上操作只保证了消息发送是原子的，那消息消费要怎么办？</li>
</ol>
<ul>
<li><p>因为消费端RocketMQ有重试机制，如果不是代码问题一般重试几次就能成功，这里我们要保证消息消费的幂等性，即多次消费同一个消息对系统的状态没有影响，或者说不会影响最终正确的结果。比如上面的案例中，发生了重复消费，可能就会重复调用多次扣款的接口，我们要保证对同一个消息多次调用和一次调用的最终结果是一致的，而不是调用几次接口就扣款几次。</p>
</li>
<li><p>如果消费者一直执行失败，几乎可以断定就是代码有问题所以才引起的异常。如果多次失败并重试达到一定次数之后，可以先将该异常记录下来，通常是记录到数据库中，后续由人工处理，通过这样来让事务达到最终的一致性。</p>
</li>
</ul>
<p>因此RocketMQ的事务消息不是强一致性的，而是保证最终一致性，并且可能需要人工介入。</p>
<p>目前，生产级别采用的各种分布式事务解决方案也几乎都是最终一致性的。试想一下，如果要保证强一致性的，即必须实时的保证数据的一致性，那么一定需要同步阻塞，此时将会阻塞大量的服务，降低消息分布式系统的可用性和并发度，这是更加不可容忍的。实际上也有强一致性的分布式事务方案，比如基于数据库的2PC实现，但是几乎很少使用，或者说，建议小公司谨慎使用分布式事务，能不用就不用。</p>
<p>与最终一致性对应的业务是，通常在客户进行操作之后，不会立即返回客户成功的信号，而是返回一个“业务正在办理中，成功了会通知你”、“钱款两小时内到账”等友好的延时提醒。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767015/article/details/121308018">https://blog.csdn.net/weixin_43767015/article/details/121308018</a></p>
</blockquote>
<ol>
<li>关于事务回查<br>在demo中本地事务返回UNKNOW并没有触发事务回查，感觉官方并不推荐使用事务回查。且即便是本地事务返回UNKNOW也不会立即回查，而是固定的时间后再去回查，而demo中producer发送完消息就关闭了。</li>
</ol>
<p>事务回查的触发条件，4.X版本的官方文档是这样描述的：</p>
<blockquote>
<p>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</p>
</blockquote>
<p>5.X的官方文档是这样描述的：</p>
<blockquote>
<p>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</p>
</blockquote>
<p>源码中也并没有对UNKNOW类型直接做处理（可能有定时器）</p>
<pre><code>if (localTransactionStatLocalTransactionState.COMMIT_MESSAGE) &#123;
    log.info(&quot;executeLocalTransactionBranch return localTransactionState);
    log.info(msg.toString());
&#125;
</code></pre>
<h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><ol>
<li>概念<br>批量发送消息需要注意的点：</li>
</ol>
<ul>
<li>批量发送的消息必须具有相同的Topic</li>
<li>批量发送的消息必须具有相同的刷盘策略</li>
<li>批量发送的消息不能是延时消息与事务消息</li>
<li>一批发送的消息总大小不能超过4MB字节</li>
</ul>
<p>生产者批量发送消息不能超过4M，所以通常需要定义一个分割器确保不会超过4M，如果需要修改最大发送长度，需要在配置文件和代码中都进行设置和修改    </p>
<p>消费者有两个属性：拉取消息的数量(pullBatchSize)、批量消费消息的数量(consumeMessageBatchMaxSize)。<br>批量消费消息的时候是批量成功或批量失败的，一条失败则全部失败，所以要适当设置批量消费的数量。   </p>
<p>另外，批量拉取和消费的数量并不一定和指定的数量一致，受网络影响，并不是一定会拉取到、消费到指定数量的消息</p>
<ol start="2">
<li>代码举例<br>定义分割器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class MessageListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int SIZE_LIMIT = 4 * 1024 * 1024;</span><br><span class="line">    // 存放所有要发送的消息</span><br><span class="line">    private final List&lt;Message&gt; messages;</span><br><span class="line">    // 要进行批量发送消息的小集合起始索引</span><br><span class="line">    private int currIndex;</span><br><span class="line"></span><br><span class="line">    public MessageListSplitter(List&lt;Message&gt; messages) &#123;</span><br><span class="line">        this.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        // 判断当前开始遍历的消息索引要小于消息总数</span><br><span class="line">        return currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Message&gt; next() &#123;</span><br><span class="line">        int nextIndex = currIndex;</span><br><span class="line">        // 记录当前要发送的这一小批次消息列表的大小</span><br><span class="line">        int totalSize = 0;</span><br><span class="line"></span><br><span class="line">        for (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            // 获取当前遍历的消息</span><br><span class="line">            Message currentMsg = messages.get(nextIndex);</span><br><span class="line">            int currentMsgSize = computeMsgSize(currentMsg);</span><br><span class="line">            // 判断当前消息本身是否大于4M</span><br><span class="line">            if (currentMsgSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                if (nextIndex - currIndex == 0) &#123;</span><br><span class="line">                    nextIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (currentMsgSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                totalSize += currentMsgSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // end-for</span><br><span class="line"></span><br><span class="line">        // 获取当前messages列表的子集合[currIndex, nextIndex)</span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">        // 下次遍历的开始索引</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        return subList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算单个消息的长度</span><br><span class="line">     *</span><br><span class="line">     * @param message</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private int computeMsgSize(Message message) &#123;</span><br><span class="line">        int size = message.getTopic().length() + message.getBody().length;</span><br><span class="line">        Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            size += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">        &#125;</span><br><span class="line">        size = size + 20;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
生产者消费者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class BatchMsgProducer &#123;</span><br><span class="line"></span><br><span class="line">    public static final String IP_PORT = &quot;121.4.247.245:9876&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sendBatchMessage() throws Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">        List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();</span><br><span class="line">        ...</span><br><span class="line">        MessageListSplitter splitter = new MessageListSplitter(messageList);</span><br><span class="line">        while (splitter.hasNext()) &#123;</span><br><span class="line">            List&lt;Message&gt; msgs = splitter.next();</span><br><span class="line">            producer.send(msgs);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//消费者不一致的地方只有</span><br><span class="line">consumer.setConsumeMessageBatchMaxSize(25);</span><br><span class="line">consumer.setPullBatchSize(40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>消费者可以对消息进行过滤，有两种方式：Tag过滤、sql过滤</p>
<ul>
<li>Tag过滤：选择订阅哪些tag，上文中订阅的都是全部，还可以这样写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(&quot;TOPIC&quot;, &quot;TAGA || TAGB || TAGC&quot;);</span><br></pre></td></tr></table></figure></li>
<li>Sql过滤：使用表达式进行更高级的过滤<br>支持的表达式：<ul>
<li>支持的常量类型：<br>数值：比如：123，3.1415<br>字符：必须用单引号包裹起来，比如：’abc’<br>布尔：TRUE 或 FALSE<br>NULL：特殊的常量，表示空</li>
<li>支持的运算符有：<br>数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;<br>字符比较：&#x3D;，&lt;&gt;，IN<br>逻辑运算 ：AND，OR，NOT<br>NULL判断：IS NULL 或者 IS NOT NULL</li>
</ul>
</li>
</ul>
<p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开<br>启该功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enablePropertyFilter = true</span><br></pre></td></tr></table></figure>

<p>使用Sql过滤：</p>
<ul>
<li>生产者添加属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.putUserProperty(&quot;age&quot;, i + &quot;&quot;);</span><br></pre></td></tr></table></figure></li>
<li>消费者过滤<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(&quot;myTopic&quot;, MessageSelector.bySql(&quot;age between 0 and 6&quot;))</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/harden_clen.jpg" alt="rxws"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">rxws</p><p class="is-size-6 is-block">rxws blog</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">消息中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RocketMq/"><span class="tag">RocketMq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">消息中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="tag">消息队列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E7%BB%B4/"><span class="tag">运维</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-15T15:19:02.000Z">2022-11-15</time></p><p class="title"><a href="/2022/11/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/">Linux服务器之间挂载共享目录</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-13T15:11:02.000Z">2022-11-13</time></p><p class="title"><a href="/2022/11/13/RocketMq%E5%85%A5%E9%97%A8/">RocketMq入门</a></p><p class="categories"><a href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="rxws" height="28"></a><p class="is-size-7"><span>&copy; 2022 chenfm</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>