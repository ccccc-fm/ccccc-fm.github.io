{"posts":[{"title":"Linux服务器之间挂载共享目录","text":"Linux现有比较成熟的解决方案有两种，一种是NFS远程挂载，另一种是Samba共享目录。下面使用NFS，即网络文件系统（Network File System）分布式文件系统协议 环境 服务端-A服务器 121.4.247.245 Centos 客户端-B服务器 1.12.221.166 Ubuntu 步骤服务端设置共享目录，客户端挂载目录 服务端-A服务器 安装NFS 由于NFS是依赖于RPC协议来进行的协议传输，所以，此时需同时安装，NFS 和 RPC 两个应用程序 1yum -y install nfs-utils rpcbind 设置共享目录 NFS的配置文件在/etc/exports，内容默认为空。配置格式为：目录位置 客户机地址(权限选项) 123vim /etc/exports//添加如下内容/sharetest 1.12.221.166(insecure,rw,no_root_squash,no_all_squash,sync) 其中，/sharetest是服务器端要共享出来的目录，1.12.221.166是客户端的ip，rw代表客户端可以对共享目录进行读写操作。 启动NFS服务12345678#启动rpc服务(stop关闭)systemctl start rpcbind#启动nfs服务(stop关闭)systemctl start nfs#查看rpc服务状态systemctl status rpcbind#查看nfs服务状态systemctl status nfs 查看当前机器已经发布的NFS共享目录1showmount -e 此时共享文件A服务器的配置已经完成，可直接在B服务器进行目录的挂载操作 客户端-B服务器 安装RPC服务1apt-get install rpcbind 挂载1mount -t nfs 121.4.247.245:/data/share /data/store df -h 查看挂载目录 开机自动挂载12vim /etc/fstab121.4.247.245:/sharetest /sharetest nfs defaults,_netdev 0 0 开机自动启动1systemctl enable rpcbind.service 注意：/etc/fstab是用来存放文件系统的静态信息的文件,当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。如果挂载的格式不正确会导致服务器启动失败，需要进入救援者模式处理，谨慎操作fstab文件。linux之fstab文件详解:https://blog.csdn.net/qq_32907195/article/details/117512634 开机自动挂载可以写脚本开机自动执行，脚本中使用命令挂载 卸载共享目录在客户端服务器卸载 1umount -l /sharetest 卸载后未生效，文件依旧会同步~~~ 其他 如果NFS服务器端的防火墙没有关闭的话，共享目录在挂载的时候就会出现挂载失败，连接超时的问题（mount.nfs:Connection timed out） 服务器端exports的客户端配置选项要加上insecure参数，例如：/sharedata 192.168.10.109(insecure,rw)。 如果不加上insecure参数的话，在挂载共享目录时，可能会提示如下错误：mount.nfs:access denied by server while mounting。 共享文件夹最好设置权限 chmod -R 777 /sharetest","link":"/2022/11/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"},{"title":"RocketMq入门","text":"介绍 MQ的用处 限流削峰 异步解耦 数据收集：收集业务日志、监控数据、用户行为 RocketMQ基础概念 消息(message): 生产和消费数据的最小单位，每条消息必须属于一个主题 主题(topic): 一类消息的集合，每个主题包含多个消息。一个生产者可以生产多个topic消息，一个消费者只能消费一个topic **标签(Tag)**：为消息设置的标签用于同一个topic下区分不同类型的消息 **队列(Queue)**：存储消息的物理实体，一个topic包含多个Queue，每个Queue中存放的就是该Topic的消息。一个topic中的queue也叫topic中消息的分区。一个queue只能被一个消费者消费 消息标识(MessageId/key): 消息的唯一标识，生产者发送消息会产生一个msgId，消费者接收消息会产生offsetMsgId，用户指定而定业务id叫key 架构 producer：生产消息 consumer：进行消息消费 负载均衡：一个topic中的queue会平均分配给消费者组中的消费者 容错：组中的一个消费者挂掉后，其他的消费者会平分该消费者的queue 消费者组只能消费一个topic的消息，不能同时消费多个topic的消息 一个消费者组中的消费者必须订阅完全相同的topic NameServer：broker和topic路由的注册中心，功能：broker管理、路由信息管理 broker：用于存储和转发消息 工作流程①:启动namerserver -&gt; ②:启动broker -&gt; ③:创建topic -&gt; ④:生产消息 -&gt; ⑤:消费消息1：namerserver因为rockermq的注册中心是无状态的，所以它的broker信息与路由信息需要broker主动发送给nameserver，所以先启动nameserver，关闭时先关闭broker2：创建topic发送消息前应该先创建topic也可以设置自动创建，手动创建topic有两种方式：集群模式和broker模式，区别在于集群模式创建的topic在每个broker中的读写队列数量都是一致的，而broker模式你需要在逐个选择broker进行创建topic，读写队列自然数量自然可以不同。手动创建topic的参数有四个：创建模式、读队列数量、写队列数量、perm。perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。3：读写队列生产者将消息写入写队列，消费者从队列中读取消息。在物理上读写队列是同一个队列，一般情况读写队列数量是相同的。但broker模式创建topic时读写队列数量不同，这样是为了缩容。缩容：如现在读写队列数量都为16个，需要缩容为都是8个，且保证消息不丢失。可以先将写队列动态调整为8个，此时只有8个写队列在往里写消息，16个队列在消费消息，待停止写入消息的那8个队列的消息消费完了之后，将读队列的数量修改为8，即实现了缩容 工作原理生产消息 生产过程： Producer发送消息之前，会先向NameServer发出获取 消息Topic的路由信息 的请求 NameServer返回该Topic的 路由表 及 Broker列表 路由表是个map，key是topic名称，value是broker列表，列表中没有地址只有名称，produer通过路由表找到brokername,再从broker列表中找到broker地址 Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息 Queue选择算法：无序消息：轮询和最小投递延迟算法 Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩 Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue 轮询算法：默认选择的算法，保证消息在队列中均匀的消费消息1发送个队列1，消息2发送给队列2，以此类推。缺点：消息1发送后，生产者要等消息成功发送后再把消息2发送给队列2，不成功下次还是给队列1发送。这样一来可能造成消息在生产者的缓存队列中大量积压，影响性能。 最小投递延迟算法统计每个队列投递消息的延迟，选择最小的队列进行投递，缺点：可能造成一个队列中存放了大量消息，造成消费者消费者能力下降，消息在MQ中积压严重 消息的存储RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。 indexFile除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在 包含了key的消息 被发送到Broker时写入的。如果消息中没有包含key，则不会写入。 消费消息 获取消息 **拉取式消费(pull)**：Consumer主动从Broker中拉取消息。实时性弱 拉取消息的时间是用户指定的，拉取时间需要注意平衡 推送式消费(push): broker收到消息后主动推送给consumer，实时性高，耗费资源 consumer向其关联的queue注册了监听器，这需要长连接，所以耗费资源(与每个broker建立长连接) **长轮询(long polling)**：消费者定时去broker中获取消息，如果没获取到消息，保持连接一段时间，比如30s，30s内没有消息，则断开连接，30s内有消息，则消费消息且再等30s。中和了pull和push的利弊。 消费消息 广播消费消费者组中的每个消费者都接收topic全量的消息，各自进行消费，一条消息被消费n次，消费进度保存在消费者中 集群消费消费者组中的消费者平摊topic所有的消息，一条消息被消费一次，进度需要共享，所以消费进度存放在broker中 代码举例rocketmq-client发送、消费消息 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; 代码 123456789101112131415161718192021222324252627282930313233@Testpublic void send() throws Exception { DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;); producer.setNamesrvAddr(&quot;121.4.247.245:9876&quot;); producer.setSendMsgTimeout(6000); producer.start(); byte[] body = &quot;123&quot;.getBytes(); Message msg = new Message(&quot;testTopic&quot;, &quot;test&quot;, body); SendResult send = producer.send(msg); producer.shutdown(); System.out.println(send);}@Testpublic void consumer() throws Exception { while (true){ DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;); consumer.setNamesrvAddr(&quot;121.4.247.245:9876&quot;); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(&quot;testTopic&quot;,&quot;*&quot;); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) { list.forEach(msg-&gt;{ System.out.println(msg.getBody()); }); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); Thread.sleep(500); }} 说明 消费者中的consumeMessage方法何时触发？ broker中收到了该消费者订阅的消息后触发，所以先发送消息，后启动消费者去消费是消费不到消息的，应该消费者一直等待消息。 疑惑 什么是pull消费者和push消费者，有何区别？ 消费者中收到的消息是什么类型的，如何解码？ bug 生产者发送1消息时如果不设置发送超时时间，或设置时间较短会报错： 1sendDefaultImpl call timeout","link":"/2022/11/13/RocketMq%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"RocketMq","slug":"RocketMq","link":"/tags/RocketMq/"},{"name":"消息中间件","slug":"消息中间件","link":"/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"消息队列","slug":"消息队列","link":"/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"消息中间件","slug":"消息中间件","link":"/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"pages":[]}