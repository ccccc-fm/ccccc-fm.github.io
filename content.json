{"posts":[{"title":"Linux服务器之间挂载共享目录","text":"Linux现有比较成熟的解决方案有两种，一种是NFS远程挂载，另一种是Samba共享目录。下面使用NFS，即网络文件系统（Network File System）分布式文件系统协议 环境 服务端-A服务器 121.4.247.245 Centos 客户端-B服务器 1.12.221.166 Ubuntu 步骤服务端设置共享目录，客户端挂载目录 服务端-A服务器 安装NFS 由于NFS是依赖于RPC协议来进行的协议传输，所以，此时需同时安装，NFS 和 RPC 两个应用程序 1yum -y install nfs-utils rpcbind 设置共享目录 NFS的配置文件在/etc/exports，内容默认为空。配置格式为：目录位置 客户机地址(权限选项) 123vim /etc/exports//添加如下内容/sharetest 1.12.221.166(insecure,rw,no_root_squash,no_all_squash,sync) 其中，/sharetest是服务器端要共享出来的目录，1.12.221.166是客户端的ip，rw代表客户端可以对共享目录进行读写操作。 启动NFS服务12345678#启动rpc服务(stop关闭)systemctl start rpcbind#启动nfs服务(stop关闭)systemctl start nfs#查看rpc服务状态systemctl status rpcbind#查看nfs服务状态systemctl status nfs 查看当前机器已经发布的NFS共享目录1showmount -e 此时共享文件A服务器的配置已经完成，可直接在B服务器进行目录的挂载操作 客户端-B服务器 安装RPC服务1apt-get install rpcbind 挂载1mount -t nfs 121.4.247.245:/data/share /data/store df -h 查看挂载目录 开机自动挂载12vim /etc/fstab121.4.247.245:/sharetest /sharetest nfs defaults,_netdev 0 0 开机自动启动1systemctl enable rpcbind.service 注意：/etc/fstab是用来存放文件系统的静态信息的文件,当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。如果挂载的格式不正确会导致服务器启动失败，需要进入救援者模式处理，谨慎操作fstab文件。linux之fstab文件详解:https://blog.csdn.net/qq_32907195/article/details/117512634 开机自动挂载可以写脚本开机自动执行，脚本中使用命令挂载 卸载共享目录在客户端服务器卸载 1umount -l /sharetest 卸载后未生效，文件依旧会同步~~~ 其他 如果NFS服务器端的防火墙没有关闭的话，共享目录在挂载的时候就会出现挂载失败，连接超时的问题（mount.nfs:Connection timed out） 服务器端exports的客户端配置选项要加上insecure参数，例如：/sharedata 192.168.10.109(insecure,rw)。 如果不加上insecure参数的话，在挂载共享目录时，可能会提示如下错误：mount.nfs:access denied by server while mounting。 共享文件夹最好设置权限 chmod -R 777 /sharetest","link":"/2022/11/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"},{"title":"RocketMq入门","text":"介绍 MQ的用处 限流削峰 异步解耦 数据收集：收集业务日志、监控数据、用户行为 RocketMQ基础概念 消息(message): 生产和消费数据的最小单位，每条消息必须属于一个主题 主题(topic): 一类消息的集合，每个主题包含多个消息。一个生产者可以生产多个topic消息，一个消费者只能消费一个topic **标签(Tag)**：为消息设置的标签用于同一个topic下区分不同类型的消息 **队列(Queue)**：存储消息的物理实体，一个topic包含多个Queue，每个Queue中存放的就是该Topic的消息。一个topic中的queue也叫topic中消息的分区。一个queue只能被一个消费者消费 消息标识(MessageId/key): 消息的唯一标识，生产者发送消息会产生一个msgId，消费者接收消息会产生offsetMsgId，用户指定而定业务id叫key 架构 producer：生产消息 consumer：进行消息消费 负载均衡：一个topic中的queue会平均分配给消费者组中的消费者 容错：组中的一个消费者挂掉后，其他的消费者会平分该消费者的queue 消费者组只能消费一个topic的消息，不能同时消费多个topic的消息 一个消费者组中的消费者必须订阅完全相同的topic NameServer：broker和topic路由的注册中心，功能：broker管理、路由信息管理 broker：用于存储和转发消息 工作流程①:启动namerserver -&gt; ②:启动broker -&gt; ③:创建topic -&gt; ④:生产消息 -&gt; ⑤:消费消息1：namerserver因为rockermq的注册中心是无状态的，所以它的broker信息与路由信息需要broker主动发送给nameserver，所以先启动nameserver，关闭时先关闭broker2：创建topic发送消息前应该先创建topic也可以设置自动创建，手动创建topic有两种方式：集群模式和broker模式，区别在于集群模式创建的topic在每个broker中的读写队列数量都是一致的，而broker模式你需要在逐个选择broker进行创建topic，读写队列自然数量自然可以不同。手动创建topic的参数有四个：创建模式、读队列数量、写队列数量、perm。perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。3：读写队列生产者将消息写入写队列，消费者从队列中读取消息。在物理上读写队列是同一个队列，一般情况读写队列数量是相同的。但broker模式创建topic时读写队列数量不同，这样是为了缩容。缩容：如现在读写队列数量都为16个，需要缩容为都是8个，且保证消息不丢失。可以先将写队列动态调整为8个，此时只有8个写队列在往里写消息，16个队列在消费消息，待停止写入消息的那8个队列的消息消费完了之后，将读队列的数量修改为8，即实现了缩容 工作原理生产消息 生产过程： Producer发送消息之前，会先向NameServer发出获取 消息Topic的路由信息 的请求 NameServer返回该Topic的 路由表 及 Broker列表 路由表是个map，key是topic名称，value是broker列表，列表中没有地址只有名称，produer通过路由表找到brokername,再从broker列表中找到broker地址 Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息 Queue选择算法：无序消息：轮询和最小投递延迟算法 Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩 Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue 轮询算法：默认选择的算法，保证消息在队列中均匀的消费消息1发送个队列1，消息2发送给队列2，以此类推。缺点：消息1发送后，生产者要等消息成功发送后再把消息2发送给队列2，不成功下次还是给队列1发送。这样一来可能造成消息在生产者的缓存队列中大量积压，影响性能。 最小投递延迟算法统计每个队列投递消息的延迟，选择最小的队列进行投递，缺点：可能造成一个队列中存放了大量消息，造成消费者消费者能力下降，消息在MQ中积压严重 消息的存储RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。 indexFile除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在 包含了key的消息 被发送到Broker时写入的。如果消息中没有包含key，则不会写入。 消费消息 获取消息 **拉取式消费(pull)**：Consumer主动从Broker中拉取消息。实时性弱 拉取消息的时间是用户指定的，拉取时间需要注意平衡 推送式消费(push): broker收到消息后主动推送给consumer，实时性高，耗费资源 consumer向其关联的queue注册了监听器，这需要长连接，所以耗费资源(与每个broker建立长连接) **长轮询(long polling)**：消费者定时去broker中获取消息，如果没获取到消息，保持连接一段时间，比如30s，30s内没有消息，则断开连接，30s内有消息，则消费消息且再等30s。中和了pull和push的利弊。 消费消息 广播消费消费者组中的每个消费者都接收topic全量的消息，各自进行消费，一条消息被消费n次，消费进度保存在消费者中 集群消费消费者组中的消费者平摊topic所有的消息，一条消息被消费一次，进度需要共享，所以消费进度存放在broker中 Rebalance机制Relablance机制指当消费者组中的消费者数量发生变化（宕机、新增）时、消费者所订阅的Topic中的Queue数量发生变化时，将Topic中的多个Queue重新分配给消费者的机制。Reblance机制的前提是集群消费。在进行Reblance时，会导致消费暂停，重新分配Queue后继续消费，这可能会导致消息重复或者暂停时间过长导致消息积压。优点是可以提升消费能力 Queue分配算法 平均分配：先根据Queue的数量和消费者的数量计算每个消费者分配的Queue数量，如不能平均分配，则将多于的Queue逐个分配个消费者。 环形平均分配：消费者逐个从Queue队列中领取，与平均分配不同的是，平均分配的Queue是连续的，比如Consumer1会拿到0、1、3的Queue，而环形会拿到0、3、6的Queue 一致hash策略：将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过 顺时针 方向，距离queue最近的那个consumer就是该queue要分配的consumer。（分配不均） 同机房分配：根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配 订阅关系一致性错误的订阅关系会导致消费逻辑混乱、丢失消息正确的订阅关系：多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。错误的订阅关系： 一个消费者组中的消费者订阅了不同的Topic 一个消费者组中的消费者订阅了相同的Topic，不同的Tag 一个消费者组中的消费者订阅了不同数量的消费者 消息幂等某个操作执行多次和执行一次对系统的影响都是一样的，则为幂等操作。读操作一般都是幂等的，幂等性一般讨论的都是写操作。对于RocketMq来说，如果出现消息重复，就可能会重复消费影响业务。 RocketMq可能出现的消息重复场景 producer将消息发送给broker，broker持久化消息后因为网络原因没有给produce发送接收到消息的响应，produce会判断为消息发送失败，会重复发送失败的消息，并不会重新生成msgId。 consumer接收到消息后没有给broker成功的响应，broker会重复给consumer发送消息 Rebalance时导致消息重复 通用的幂等性解决方案通常通过幂等令牌实现幂等性操作，如支付操作：producer发送消息时带上幂等令牌，支付中可能是订单号。consumer处理消息时进行三步处理： 检查缓存中有无与令牌相同的key，如存在则认定为重复操作，如不存在则进行下一步 检查数据库中有无该令牌为索引的数据，如存在则认定为重复操作，不存在则进行下一步 进行到这一步就已经认定为未重复，进行业务操作，然后将令牌存入缓存、数据库 为什么缓存中判重后还要在数据库中再次判重？因为为了性能，缓存中一般存的都是有有效期的，存在key过期而不存在的情况 在RocketMq中producer可以在发送消息时将幂等令牌设置为消息的key 1message.setKey(&quot;XXXXX&quot;) message的标识有三个：msgId(producer生成)、offsetMsgId(broker生成)、key(用户指定的业务唯一标识) 代码举例rocketmq-client 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; 普通消息消息根据发送类型分为： 同步发送：producer发送一条消息后，收到MQ的响应后发送下一条消息，可靠性高效率低 异步发送：无需等待响应(但会接收响应)，直接发送下一条，可靠性一般、效率一般 单向发送：不接收响应，可靠性差，效率高 producer发送消息 123456789//失败重试次数、默认2次producer.setRetryTimesWhenSendFailed(3);//发送超时时间，默认3秒，单向消息设置超时时间貌似会报超时错误//超时错误：sendDefaultImpl call timeoutproducer.setSendMsgTimeout(5000);//指定新创建的Topic的Queue数量为2，默认为4producer.setDefaultTopicQueueNums(2); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 发送同步消息 * @throws Exception */@Testpublic void syncSend() throws Exception { DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;); producer.setNamesrvAddr(IP_PORT); producer.start(); byte[] body = &quot;123&quot;.getBytes(); Message msg = new Message(&quot;testSyncTopic&quot;, &quot;test&quot;, body); SendResult send = producer.send(msg); producer.shutdown();}/** * 发送异步消息 * @throws Exception */@Testpublic void asyncSend() throws Exception { DefaultMQProducer producer = new DefaultMQProducer(&quot;myAsyncGroup&quot;); producer.setNamesrvAddr(IP_PORT); producer.start(); byte[] body = &quot;test&quot;.getBytes(); Message msg = new Message(&quot;testSyncTopic&quot;, &quot;test&quot;, body); producer.send(msg, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { //发送成功的回调，sendResult为返回结果 System.out.println(sendResult); } @Override public void onException(Throwable throwable) { //发送失败的异常信息 System.out.println(throwable.getMessage()); } }); //异步发送，如果直接关闭生产者，可能消息还没发完 Thread.sleep(3000); producer.shutdown();}/** * 发送单单向消息 * @throws Exception */@Testpublic void oneWaySend() throws Exception { DefaultMQProducer producer = new DefaultMQProducer(&quot;myAsyncGroup&quot;); producer.setNamesrvAddr(IP_PORT); producer.start(); byte[] body = &quot;test&quot;.getBytes(); Message msg = new Message(&quot;testOneWayTopic&quot;, &quot;test&quot;, body); producer.sendOneway(msg); producer.shutdown();} consumer接收消息 12// 指定采用“广播模式”进行消费，默认为“集群模式”consumer.setMessageModel(MessageModel.BROADCASTING); 1234567891011121314151617181920212223242526 /** * 接收消息 * @throws Exception */ @Test public void consumer() throws Exception { while (true){ System.out.println(&quot;into&quot;); DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;); consumer.setNamesrvAddr(IP_PORT); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(&quot;testSyncTopic&quot;,&quot;*&quot;);// consumer.subscribe(&quot;testOneWayTopic&quot;,&quot;*&quot;); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) { list.forEach(msg-&gt;{ System.out.println(new String(msg.getBody())); }); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); Thread.sleep(5000); } } 顺序消息顺序消息指的是，严格按照消息的 发送顺序 进行 消费 的消息(FIFO)。 普通消息为什么不是顺序的？producer生产消息后会根据算法(轮询、最小投递)将消息投递到不同的Queue中，每个Queue中虽然是先进先出的，但是不同Queue中的消费速度可不一样，将消息投递到不同的Queue中当然不是顺序的。所以要保证消息的顺序，就要保证消息在同一个Queue中，比如一个订单的三条消息：创建、付款、完成。三条都在一个Queue中。注意:一个Queue只能被一个消费者消费，所以放在一个Queue中就是顺序的 如何保证消息在一个Queue中？ producer设置Topic下的Queue数量为1.称之为全局顺序 producer通过Queue选择算法指定消息投递到哪个Queue中，订单场景中就是设置每个订单的三个消息都能进到同一个Queue中，称之为部分顺序 全局顺序与部分顺序的代码是相同的。Queue选择算法就是通过计算得出消息投递的Queue索引，相同订单的三个消息计算出的索引是相同的，就会被投递到同一队列。常用的方法就是Hash取模，用订单ID%队列数量得到Queue索引 如何完成一次顺序消息的发送、消费？ 保证消息在同一个Queue中 同步发送，顺序消息只能用同步发送(虽然提供了异步方法，但不能保证有序) consumer使用有序消费模式进行消费MessageListenerOrderly 代码注意：订单id是通过send方法的第三个参数传递进去的、消费者中用顺序监听器最后观察消费者的输出，同一个订单的消息都在同一个Queue中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 发送顺序消息 * @throws Exception */@Testpublic void syncSend() throws Exception { DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;); producer.setNamesrvAddr(IP_PORT); producer.start(); Integer[] orderIds =new Integer[]{111,222,333}; for (Integer i = 0; i &lt; 13; i++) { //有4条消息的orderId是111，这4条消息计算Queue索引时都是相同的，就会被投递到相同的队列中 int index = i%3; Integer orderId = orderIds[index]; byte[] body = orderId.toString().concat(&quot;-&quot;).concat(i.toString()).getBytes(); Message msg = new Message(&quot;testOrderlyTopic&quot;, &quot;test&quot;, body); //传递三个参数：message,选择器,选择器Key 这个选择器key就是内部类方法select()的参数 SendResult sendResult = producer.send(msg, new MessageQueueSelector() { @Override public MessageQueue select(List&lt;MessageQueue&gt; list, Message message, Object key) { Integer orderId = (Integer) key; //计算投递的Queue的索引 int queueIndex = orderId % list.size(); return list.get(queueIndex); } },orderId); } producer.shutdown();}/** * 接收消息 * @throws Exception */@Testpublic void consumer() throws Exception { while (true){ System.out.println(&quot;into&quot;); DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;); consumer.setNamesrvAddr(IP_PORT); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(&quot;testOrderlyTopic&quot;,&quot;*&quot;); consumer.registerMessageListener(new MessageListenerOrderly() { @Override public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext) { list.forEach(entity-&gt;{ int queueId = entity.getQueueId(); String bodyString = new String(entity.getBody()); System.out.println(queueId+&quot;----&quot;+bodyString); }); return ConsumeOrderlyStatus.SUCCESS; } }); consumer.start(); Thread.sleep(500); }} 延时消息事务消息批量消息","link":"/2022/11/13/RocketMq%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"RocketMq","slug":"RocketMq","link":"/tags/RocketMq/"},{"name":"消息中间件","slug":"消息中间件","link":"/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"消息队列","slug":"消息队列","link":"/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"消息中间件","slug":"消息中间件","link":"/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"pages":[]}