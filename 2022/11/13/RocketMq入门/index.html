<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>RocketMq入门</title>
<meta name="keywords" content="RocketMq入门, rxws">
<meta name="description" content="介绍
MQ的用处


限流削峰
异步解耦
数据收集：收集业务日志、监控数据、用户行为

RocketMQ基础概念
消息(message): 生产和消费数据的最小单位，每条消息必须属于一个主题
主题(topic): 一类消息的集合，每个主题包">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">







  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://rxws.com">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="http://rxws.com">
        <h1 class="site-title">rxws</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">RocketMq入门</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2022-11-13</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/RocketMq/">
              RocketMq
                
                  ，
                
              </a>
            
              <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">
              消息中间件
                
                  ，
                
              </a>
            
              <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">
              消息队列
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>MQ的用处</li>
</ol>
<ul>
<li>限流削峰</li>
<li>异步解耦</li>
<li>数据收集：收集业务日志、监控数据、用户行为</li>
</ul>
<h2 id="RocketMQ基础"><a href="#RocketMQ基础" class="headerlink" title="RocketMQ基础"></a>RocketMQ基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>消息(message)</strong>: 生产和消费数据的最小单位，每条消息必须属于一个主题</li>
<li><strong>主题(topic)</strong>: 一类消息的集合，每个主题包含多个消息。一个生产者可以生产多个topic消息，一个消费者只能消费一个topic</li>
<li>**标签(Tag)**：为消息设置的标签用于同一个topic下区分不同类型的消息</li>
<li>**队列(Queue)**：存储消息的物理实体，一个topic包含多个Queue，每个Queue中存放的就是该Topic的消息。一个topic中的queue也叫topic中消息的分区。一个queue只能被一个消费者消费</li>
<li><strong>消息标识(MessageId&#x2F;key)</strong>: 消息的唯一标识，生产者发送消息会产生一个msgId，消费者接收消息会产生offsetMsgId，用户指定而定业务id叫key</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ol>
<li>producer：生产消息</li>
<li>consumer：进行消息消费</li>
</ol>
<ul>
<li>负载均衡：一个topic中的queue会平均分配给消费者组中的消费者</li>
<li>容错：组中的一个消费者挂掉后，其他的消费者会平分该消费者的queue</li>
<li>消费者组只能消费一个topic的消息，不能同时消费多个topic的消息</li>
<li>一个消费者组中的消费者必须订阅完全相同的topic</li>
</ul>
<ol start="3">
<li>NameServer：broker和topic路由的注册中心，功能：broker管理、路由信息管理</li>
<li>broker：用于存储和转发消息</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>①:启动namerserver -&gt; ②:启动broker -&gt; ③:创建topic -&gt; ④:生产消息 -&gt; ⑤:消费消息<br>1：<strong>namerserver</strong><br>因为rockermq的注册中心是无状态的，所以它的broker信息与路由信息需要broker主动发送给nameserver，所以先启动nameserver，关闭时先关闭broker<br>2：<strong>创建topic</strong><br>发送消息前应该先创建topic也可以设置自动创建，手动创建topic有两种方式：集群模式和broker模式，区别在于集群模式创建的topic在每个broker中的读写队列数量都是一致的，而broker模式你需要在逐个选择broker进行创建topic，读写队列自然数量自然可以不同。<br>手动创建topic的参数有四个：创建模式、读队列数量、写队列数量、perm。perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。<br>3：<strong>读写队列</strong><br>生产者将消息写入写队列，消费者从队列中读取消息。在物理上读写队列是同一个队列，一般情况读写队列数量是相同的。但broker模式创建topic时读写队列数量不同，这样是为了缩容。<br><code>缩容</code>：如现在读写队列数量都为16个，需要缩容为都是8个，且保证消息不丢失。可以先将写队列动态调整为8个，此时只有8个写队列在往里写消息，16个队列在消费消息，待停止写入消息的那8个队列的消息消费完了之后，将读队列的数量修改为8，即实现了缩容</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><ol>
<li><strong>生产过程</strong>：<ul>
<li>Producer发送消息之前，会先向NameServer发出获取 消息Topic的路由信息 的请求</li>
<li>NameServer返回该Topic的 路由表 及 Broker列表<blockquote>
<p>路由表是个map，key是topic名称，value是broker列表，列表中没有地址只有名称，produer通过路由表找到brokername,再从broker列表中找到broker地址</p>
</blockquote>
</li>
<li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息<blockquote>
<p>Queue选择算法：无序消息：轮询和最小投递延迟算法</p>
</blockquote>
</li>
<li>Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</li>
<li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue<blockquote>
<p>轮询算法：<br>默认选择的算法，保证消息在队列中均匀的消费<br>消息1发送个队列1，消息2发送给队列2，以此类推。缺点：消息1发送后，生产者要等消息成功发送后再把消息2发送给队列2，不成功下次还是给队列1发送。这样一来可能造成<strong>消息在生产者的缓存队列中大量积压</strong>，影响性能。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>最小投递延迟算法<br>统计每个队列投递消息的延迟，选择最小的队列进行投递，缺点：可能造成一个队列中存放了大量消息，造成消费者消费者能力下降，<strong>消息在MQ中积压严重</strong></p>
</blockquote>
<ol start="2">
<li>消息的存储<br>RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。</li>
<li>indexFile<br>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询<br>是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索<br>引数据是在 包含了key的消息 被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</li>
</ol>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><ol>
<li><strong>获取消息</strong></li>
</ol>
<ul>
<li>**拉取式消费(pull)**：Consumer主动从Broker中拉取消息。实时性弱<blockquote>
<p>拉取消息的时间是用户指定的，拉取时间需要注意平衡</p>
</blockquote>
</li>
<li><strong>推送式消费(push)</strong>: broker收到消息后主动推送给consumer，实时性高，耗费资源<blockquote>
<p>consumer向其关联的queue注册了监听器，这需要长连接，所以耗费资源(与每个broker建立长连接)</p>
</blockquote>
</li>
<li>**长轮询(long polling)**：消费者定时去broker中获取消息，如果没获取到消息，保持连接一段时间，比如30s，30s内没有消息，则断开连接，30s内有消息，则消费消息且再等30s。中和了pull和push的利弊。</li>
</ul>
<ol start="2">
<li><strong>消费消息</strong></li>
</ol>
<ul>
<li><strong>广播消费</strong><br>消费者组中的每个消费者都接收topic全量的消息，各自进行消费，一条消息被消费n次，消费进度保存在消费者中</li>
<li><strong>集群消费</strong><br>消费者组中的消费者平摊topic所有的消息，一条消息被消费一次，进度需要共享，所以消费进度存放在broker中</li>
</ul>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><h4 id="rocketmq-client发送、消费消息"><a href="#rocketmq-client发送、消费消息" class="headerlink" title="rocketmq-client发送、消费消息"></a>rocketmq-client发送、消费消息</h4><ul>
<li><p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void send() throws Exception &#123;</span><br><span class="line">    DefaultMQProducer producer = new DefaultMQProducer(&quot;myGroup&quot;);</span><br><span class="line">    producer.setNamesrvAddr(&quot;121.4.247.245:9876&quot;);</span><br><span class="line">    producer.setSendMsgTimeout(6000);</span><br><span class="line">    producer.start();</span><br><span class="line">    byte[] body = &quot;123&quot;.getBytes();</span><br><span class="line">    Message msg = new Message(&quot;testTopic&quot;, &quot;test&quot;, body);</span><br><span class="line">    SendResult send = producer.send(msg);</span><br><span class="line">    producer.shutdown();</span><br><span class="line">    System.out.println(send);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void consumer() throws Exception &#123;</span><br><span class="line">    while (true)&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(&quot;myConsumerGroup&quot;);</span><br><span class="line">        consumer.setNamesrvAddr(&quot;121.4.247.245:9876&quot;);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(&quot;testTopic&quot;,&quot;*&quot;);</span><br><span class="line">        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                list.forEach(msg-&gt;&#123;</span><br><span class="line">                    System.out.println(msg.getBody());</span><br><span class="line">                &#125;);</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明</p>
<ol>
<li>消费者中的consumeMessage方法何时触发？<br>  broker中收到了该消费者订阅的消息后触发，所以先发送消息，后启动消费者去消费是消费不到消息的，应该消费者一直等待消息。</li>
</ol>
</li>
<li><p>疑惑</p>
<ol>
<li>什么是pull消费者和push消费者，有何区别？</li>
<li>消费者中收到的消息是什么类型的，如何解码？</li>
</ol>
</li>
<li><p>bug</p>
<ol>
<li>生产者发送1消息时如果不设置发送超时时间，或设置时间较短会报错：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendDefaultImpl call timeout</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BB%8B%E7%BB%8D"><span class="top-box-text">介绍</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#RocketMQ%E5%9F%BA%E7%A1%80"><span class="top-box-text">RocketMQ基础</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A6%82%E5%BF%B5"><span class="top-box-text">概念</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%B6%E6%9E%84"><span class="top-box-text">架构</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="top-box-text">工作流程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="top-box-text">工作原理</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="top-box-text">代码举例</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

